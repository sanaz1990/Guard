# Guard
Guard is a secure routing protocol for skip-graphs. It makes use of digital signature schemes and supervisor nodes called *guards* to assert the correctness during the lookup operations.
This particular implementation makes use of [jPBC library](http://gas.dia.unisa.it/projects/jpbc/) and a heavily modified version of the open-source SkipGraph implementation provided [here](https://github.com/yhassanzadeh13/SkipGraphNode).
## Layers
This implementation makes use of a layered architecture. From bottom to top, the layers for an authenticated node are as following:
1. **Communication layer:** Handles node-to-node communication.
2. **Authentication layer:** Implements the phases of Guard. Inserts & verifies the authentication meta-data related to authenticated search queries.
3. **Skip node layer:** Implements a skip-graph DHT node. Supports `search` and `join` operations.
4. **User interface:** Coordinates the authenticated/unauthenticated `search`, `join` operations. Per-node experiments are also handled by this layer.

Guard also makes use of a trusted third party (TTP) during the registration, construction and guard assignment phases. TTP also acts as the experiment controller. It is implemented as a separate application, and its layers are as following:
1. **Communication layer:** Handles TTP-to-node and node-to-TTP communication.
2. **TTP layer:** Contains the trusted third party protocols (e.g. registration) specific to Guard.
3. **TTP user interface:** Used to coordinate the experiment from a central point.

Each layer is implemented by extending the `Layer` abstract class. The specific layer implementations reside in their own packages.

## System parameters
The system parameters are defined under the `ttp` package, in `SystemParameters.java` file. System parameters are initialized at the TTP, and at the registration phase, they are transferred to the nodes. Here are the explanations of the parameters:
1. **SYSTEM_CAPACITY:** The number of nodes that the skip-graph contains. This implementation does not handle churn. In other words, `SYSTEM_CAPACITY` many nodes needs to register with the TTP before the lookups can be performed, and once joined, the nodes cannot depart from the system.
2. **IDENTITY_LENGTH:** Identity length for the digital signature scheme. This value should be larger than 256, as the messages are signed by two identities: name ID of a node, and the SHA-256 output of the numerical ID of a node.
3. **MESSAGE_LENGTH:** Message length for the digital signature scheme. This value denotes the length (in bytes) of the routing transcripts.
4. **NONCE_LENGTH:** Each lookup operation is assigned with a nonce, which is a random bit string. This denotes the length of the bit string.
5. **VERIFY_AT_INITIATOR:** Once this is set to true, the set of routing proofs received at the end of an authenticated search all are verified at the initiator of the search.
6. **VERIFY_AT_ROUTER:** Once this is set to true, each node in the search path verifies the routing proof generated by the previous node in the search path.

### Experiment parameters
We define an experiment in terms of *rounds*. An experiment is complete when each node successfully performs a pre-defined amount of rounds.
A *round* is defined as following
1. The node chooses a random numerical ID.
2. The node performs an unauthenticated search over the skip-graph for the chosen numerical ID.
3. The node performs an authenticated search over the skip-graph for the chosen numerical ID.

The parameters related to the experiment is also defined in the `SystemParameters.java` file: 
1. **ROUND_COUNT:** Denotes how many rounds a single node needs to complete.
2. **WAIT_TIME:** In order to avoid congestion, the nodes wait before proceeding to the next round. The waiting time (in seconds) is chosen uniformly from [0, `WAIT_TIME`].
## Running
This implementation of Guard requires Java 11 to run. Please install the appropriate JRE before running. 

To run Guard, go to the `out` directory where the `Guard.jar` can be found. This executable can be run in two different modes: (1) TTP mode, and (2) node mode.
Each system needs to have one TTP and `SYSTEM_CAPACITY` many nodes. To run as TTP, do the following:
```bash
$ java -jar Guard.jar ttp <port>
```
where `<port>` corresponds to the port number that the TTP should run on.


To run as a node, do the following:
```bash
$ java -jar Guard.jar node <port> <TTP address>
```
where `<port>` corresponds to the port number that the node should run on, and `<TTP address>` corresponds to the address of the TTP. Making use of this address,
the node registers itself with the TTP (at the registration phase) and acquires its guards (at the guard assignment phase.)  


## Node operations
Once you run the application in `node` mode, the node will automatically register with the TTP and insert itself into the skip graph. The introducer is acquired from the TTP during registration. After these are complete, you will have the following options:
1. **Info:** Reports the information about the node (e.g. numerical ID) that was acquired from the TTP.
2. **Initialize:** Runs the construction phase (constructs the table proof) and guard assignment phase (acquires the guards) for this node.
3. **Search:** Initiates a search from this node.
4. **Start experiments:** Starts running the experiments only from this node. In other words, this node will perform `ROUND_COUNT` many *round*s.

## TTP operations
1. **Show registered nodes:** Shows the list of registered nodes.
2. **Broadcast initialize requests:** Initializes every registered node (i.e. runs the construction and guard assignment phases) and makes the skip-graph ready for authenticated searches.
3. **Start experiments:** Runs the experiments. Each node will perform `ROUND_COUNT` many *round*s to complete the experiment.
4. **Terminate the skip-graph:** Terminates the TTP and remotely terminates every registered node in the skip-graph.

After all the nodes are registered with the TTP, the whole experiment can be controlled through TTP.
In order to take measurements, the operations need to be performed with respect to their numerical order (i.e. first 2, then 3, and finally 4.) 

## Taking measurements